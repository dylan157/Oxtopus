<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Octopus Agile Price Display – Interactive Chart & Auto Region</title>

  <!-- OPTIONAL FONT -->
  <link rel="preconnect" href="https://fonts.googleapis.com"/>
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin/>
  <link
    href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;700&display=swap"
    rel="stylesheet"
  />

  <style>
    /************************************************************************************************
     *                                   BASE / RESET                                               *
     ************************************************************************************************/
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      font-family: 'Roboto', sans-serif;
      background-color: #1E0D35; /* Dark purple background */
      color: #FFFFFF; /* White text for contrast */
    }

    /************************************************************************************************
     *                             MAIN CONTAINER & ANIMATION                                       *
     ************************************************************************************************/
    .main-container {
      width: 95%;
      max-width: 900px;
      background-color: #2B1240;
      border-radius: 8px;
      box-shadow: 0 8px 30px rgba(0, 0, 0, 0.4);
      padding: 20px;
      margin: 20px auto;
      display: flex;
      flex-direction: column;
      gap: 20px;
      animation: fadeIn 0.8s ease-in-out;
    }
    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(-5px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    /************************************************************************************************
     *                                   HEADER SECTION                                             *
     ************************************************************************************************/
    .header-section {
      text-align: center;
    }
    .header-section h1 {
      color: #FF00E5;
      font-size: 1.8rem;
      margin-bottom: 10px;
      font-weight: 700;
    }
    .header-section p {
      font-size: 0.9rem;
      color: #CCCCCC;
    }

    .region-selector {
      margin-top: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }
    .region-selector label {
      font-size: 0.9rem;
      color: #FF00E5;
    }
    .region-selector select {
      padding: 5px 10px;
      border-radius: 4px;
      border: 1px solid #999;
      background-color: #3A1D50;
      color: #FFFFFF;
    }
    .region-selector select:focus {
      outline: 1px solid #FF00E5;
    }
    .auto-detect-btn {
      padding: 5px 10px;
      border-radius: 4px;
      border: 1px solid #999;
      background-color: #FF00E5;
      color: #FFFFFF;
      cursor: pointer;
    }
    .auto-detect-btn:hover {
      opacity: 0.9;
    }

    /************************************************************************************************
     *                                   CURRENT PRICE SECTION                                      *
     ************************************************************************************************/
    .current-price-section {
      background-color: #3A1D50;
      border-radius: 6px;
      padding: 15px;
      text-align: center;
    }
    .price-display {
      font-size: 1.6rem;
      font-weight: 700;
      margin-bottom: 10px;
    }
    .timestamp-display {
      font-size: 0.9rem;
      color: #BBBBBB;
    }

    /************************************************************************************************
     *                                       METRICS SECTION                                        *
     ************************************************************************************************/
    .metrics-section {
      background-color: #3A1D50;
      border-radius: 6px;
      padding: 15px;
    }
    .metrics-title {
      font-size: 1.2rem;
      font-weight: 700;
      margin-bottom: 10px;
      text-align: center;
      color: #FF00E5;
    }
    .metrics-grid {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 10px;
      margin-top: 10px;
    }
    .metric-item {
      background-color: #4A2E60;
      padding: 10px;
      border-radius: 6px;
      text-align: center;
    }
    .metric-item h2 {
      font-size: 1.1rem;
      margin-bottom: 5px;
      color: #FF00E5;
    }
    .metric-item p {
      font-size: 1rem;
      color: #FFFFFF;
    }

    /************************************************************************************************
     *                                  PRICE TABLE SECTION                                         *
     ************************************************************************************************/
    .price-table-section {
      background-color: #3A1D50;
      border-radius: 6px;
      padding: 15px;
    }
    .price-table-title {
      font-size: 1.2rem;
      font-weight: 700;
      margin-bottom: 10px;
      text-align: center;
      color: #FF00E5;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 10px;
    }
    thead {
      background-color: #4A2E60;
    }
    thead th {
      padding: 8px;
      font-size: 0.9rem;
      font-weight: 700;
      color: #FFFFFF;
    }
    tbody tr {
      border-bottom: 1px solid #4A2E60;
    }
    tbody tr:hover {
      background-color: #5B3E70;
    }
    td {
      padding: 8px;
      font-size: 0.9rem;
      text-align: center;
      color: #FFFFFF;
    }

    /* Color-coded backgrounds for "price goodness" */
    /* Adjust thresholds as desired. Example: <15 = green, <25 = orange, else red. */
    .price-good {
      background-color: rgba(0, 255, 0, 0.2); /* light green overlay */
    }
    .price-ok {
      background-color: rgba(255, 165, 0, 0.2); /* light orange overlay */
    }
    .price-bad {
      background-color: rgba(255, 0, 0, 0.2); /* light red overlay */
    }

    /************************************************************************************************
     *                                      CHART SECTION                                           *
     *  We'll add an interactive tooltip that appears near hovered data points.                    *
     ************************************************************************************************/
    .chart-section {
      background-color: #3A1D50;
      border-radius: 6px;
      padding: 15px;
      position: relative;
    }
    .chart-section-title {
      font-size: 1.2rem;
      font-weight: 700;
      margin-bottom: 10px;
      text-align: center;
      color: #FF00E5;
    }
    .chart-container {
      position: relative;
      width: 100%;
      height: 300px;
    }
    .chart-container canvas {
      width: 100%;
      height: 100%;
      background-color: #4A2E60;
      border-radius: 6px;
      display: block;
    }
    /* Tooltip for chart interactivity */
    .chart-tooltip {
      position: absolute;
      background-color: #222222;
      color: #FFFFFF;
      padding: 6px 8px;
      font-size: 0.8rem;
      border-radius: 4px;
      pointer-events: none; /* so it doesn't block mouse events */
      opacity: 0;
      transition: opacity 0.1s ease-in-out;
      white-space: nowrap;
    }

    /************************************************************************************************
     *                                 TOMORROW PREVIEW SECTION                                     *
     ************************************************************************************************/
    .tomorrow-section {
      background-color: #3A1D50;
      border-radius: 6px;
      padding: 15px;
    }
    .tomorrow-title {
      font-size: 1.2rem;
      font-weight: 700;
      margin-bottom: 10px;
      text-align: center;
      color: #FF00E5;
    }
    .tomorrow-content {
      text-align: center;
      color: #FFFFFF;
    }

    /************************************************************************************************
     *                                 DEBUG SECTION                                                *
     ************************************************************************************************/
    .debug-section {
      background-color: rgba(255, 0, 0, 0.1);
      color: #ff8080;
      font-size: 0.8rem;
      padding: 10px;
      margin-top: 10px;
      border-radius: 6px;
      display: none;
      word-wrap: break-word;
    }

    /************************************************************************************************
     *                                  RESPONSIVE ADJUSTMENTS                                      *
     ************************************************************************************************/
    @media (max-width: 768px) {
      .metrics-grid {
        grid-template-columns: 1fr;
      }
      table thead, table tbody {
        font-size: 0.8rem;
      }
    }
    @media (max-width: 480px) {
      .header-section h1 {
        font-size: 1.4rem;
      }
      .price-display {
        font-size: 1.4rem;
      }
      .metrics-title,
      .price-table-title,
      .chart-section-title,
      .tomorrow-title {
        font-size: 1.0rem;
      }
    }
  </style>
</head>
<body>
  <div class="main-container">
    <!-- HEADER -->
    <div class="header-section">
      <h1>Octopus Agile Price - Interactive & Auto Region</h1>
      <p>Shows an interactive chart, color-coded intervals, and can detect your region.</p>
      <div class="region-selector">
        <label for="regionSelect">Select Region:</label>
        <select id="regionSelect">
          <!-- Some standard region codes -->
          <option value="A">A (Eastern England)</option>
          <option value="B">B (East Midlands)</option>
          <option value="C">C (London)</option>
          <option value="D">D (Merseyside & N. Wales)</option>
          <option value="E">E (West Midlands)</option>
          <option value="F">F (N. Eastern England)</option>
          <option value="G">G (North Western)</option>
          <option value="H">H (Southern England)</option>
          <option value="J">J (South Eastern)</option>
          <option value="K">K (Southern Scotland)</option>
          <option value="L">L (Northern Scotland)</option>
          <option value="M">M (South Wales)</option>
          <option value="N">N (South Western)</option>
          <option value="P">P (Yorkshire)</option>
        </select>
        <button class="auto-detect-btn" id="autoDetectBtn">Auto-Detect Region</button>
      </div>
    </div>

    <!-- CURRENT PRICE SECTION -->
    <div class="current-price-section">
      <div id="price" class="price-display">Loading current price...</div>
      <div id="timestamp" class="timestamp-display"></div>
    </div>

    <!-- METRICS SECTION -->
    <div class="metrics-section">
      <div class="metrics-title">Today's Summary</div>
      <div class="metrics-grid">
        <div class="metric-item">
          <h2>Min Price</h2>
          <p id="minPriceValue">-</p>
        </div>
        <div class="metric-item">
          <h2>Max Price</h2>
          <p id="maxPriceValue">-</p>
        </div>
        <div class="metric-item">
          <h2>Average</h2>
          <p id="avgPriceValue">-</p>
        </div>
      </div>
    </div>

    <!-- PRICE TABLE SECTION -->
    <div class="price-table-section">
      <div class="price-table-title">Half-Hourly Price Data (Today)</div>
      <table>
        <thead>
          <tr>
            <th>Time From</th>
            <th>Time To</th>
            <th>Price (p/kWh)</th>
          </tr>
        </thead>
        <tbody id="priceTableBody"><!-- Populated by JS --></tbody>
      </table>
    </div>

    <!-- CHART SECTION -->
    <div class="chart-section">
      <div class="chart-section-title">Today's Price Chart</div>
      <div class="chart-container">
        <canvas id="priceChart"></canvas>
        <!-- Tooltip element for hovering data points -->
        <div id="chartTooltip" class="chart-tooltip"></div>
      </div>
    </div>

    <!-- TOMORROW PREVIEW -->
    <div class="tomorrow-section">
      <div class="tomorrow-title">Tomorrow's Preview</div>
      <div class="tomorrow-content" id="tomorrowContent">Checking tomorrow's data...</div>
    </div>

    <!-- DEBUG SECTION -->
    <div id="debug" class="debug-section"></div>
  </div> <!-- END main-container -->

  <script>
    /************************************************************************************************
     *                          GLOBAL VARIABLES & ELEMENT REFERENCES                               *
     ************************************************************************************************/
    const OCTOPUS_API_BASE = 'https://api.octopus.energy/v1/products/AGILE-18-02-21';
    let currentRegion = 'A'; // default if geolocation fails
    let todayData = [];
    let tomorrowData = [];

    // DOM elements
    const regionSelectEl    = document.getElementById('regionSelect');
    const autoDetectBtnEl   = document.getElementById('autoDetectBtn');
    const priceEl           = document.getElementById('price');
    const timestampEl       = document.getElementById('timestamp');
    const priceTableBodyEl  = document.getElementById('priceTableBody');
    const minPriceValueEl   = document.getElementById('minPriceValue');
    const maxPriceValueEl   = document.getElementById('maxPriceValue');
    const avgPriceValueEl   = document.getElementById('avgPriceValue');
    const tomorrowContentEl = document.getElementById('tomorrowContent');
    const debugEl           = document.getElementById('debug');

    // Chart canvas & tooltip
    const priceChartCanvas  = document.getElementById('priceChart');
    const priceChartCtx     = priceChartCanvas.getContext('2d');
    const chartTooltipEl    = document.getElementById('chartTooltip');

    // We'll keep track of the chart points for interactivity
    let chartPoints = [];

    /************************************************************************************************
     *                                EVENT LISTENERS                                               *
     ************************************************************************************************/
    regionSelectEl.addEventListener('change', () => {
      currentRegion = regionSelectEl.value;
      main(); // re-fetch & re-render
    });

    autoDetectBtnEl.addEventListener('click', () => {
      // Attempt geolocation
      if (navigator.geolocation) {
        navigator.geolocation.getCurrentPosition(
          position => {
            const { latitude, longitude } = position.coords;
            const guessedRegion = guessRegionByLocation(latitude, longitude);
            currentRegion = guessedRegion;
            regionSelectEl.value = guessedRegion; // sync dropdown
            main();
          },
          error => {
            showDebug('Geolocation failed or was denied. Using default region A.');
            currentRegion = 'A';
            regionSelectEl.value = 'A';
            main();
          }
        );
      } else {
        showDebug('Geolocation not supported by this browser. Using default region A.');
        currentRegion = 'A';
        regionSelectEl.value = 'A';
        main();
      }
    });

    // Chart interactivity: handle mouse move/touch move
    priceChartCanvas.addEventListener('mousemove', onCanvasHover);
    priceChartCanvas.addEventListener('touchmove', onCanvasHover);

    // Re-render chart on window resize
    window.addEventListener('resize', () => {
      renderChart();
    });

    /************************************************************************************************
     *                          APPROXIMATE REGION GUESSING BY LAT/LON                              *
     ************************************************************************************************/
    function guessRegionByLocation(lat, lon) {
      // This is a TOTALLY MADE-UP bounding box approach, not official.
      // In reality, the UK distribution regions are not perfect squares.
      // For demonstration, we'll define some extremely rough boundaries.
      // If none match, default to 'A'.

      // Example approach: first check if user is within the UK
      // (rough bounding box: lat ~ 49..59, lon ~ -8..2)
      const isInUK = lat >= 49 && lat <= 59 && lon >= -8 && lon <= 2;
      if (!isInUK) {
        return 'A'; // default
      }
      // We'll define some rough dividing lines for demonstration:
      // e.g., North vs South, East vs West. This is not accurate!
      if (lat > 55) {
        // Let's guess region L or K for Northern Scotland
        return (lon < -3) ? 'L' : 'K';
      } else if (lat > 53) {
        // Middle belt: maybe G or F or P?
        if (lon < -2) return 'G';
        if (lon < 0)  return 'F';
        return 'P';
      } else if (lat > 51) {
        // Could be A, B, C, E
        if (lon < -2) return 'B';
        if (lon < -1) return 'A';
        return 'C'; // or E
      } else {
        // Far south might be H, J, M, N
        if (lon < -3) return 'M';
        if (lon < -1) return 'N';
        return 'H'; // fallback
      }
    }

    /************************************************************************************************
     *                              FETCH DATA FROM OCTOPUS                                         *
     ************************************************************************************************/
    async function fetchAgileData(region) {
      const url = `${OCTOPUS_API_BASE}/electricity-tariffs/E-1R-AGILE-18-02-21-${region}/standard-unit-rates/`;
      try {
        const response = await fetch(url);
        if (!response.ok) {
          throw new Error(`HTTP error! Status: ${response.status}`);
        }
        const data = await response.json();
        return data;
      } catch (error) {
        throw error;
      }
    }

    /************************************************************************************************
     *                          PARSE DATA INTO TODAY & TOMORROW                                    *
     ************************************************************************************************/
    function separateTodayAndTomorrowData(results) {
      todayData = [];
      tomorrowData = [];
      const now = new Date();
      const todayDateString = formatDateYYYYMMDD(now);

      const tomorrowDate = new Date(now);
      tomorrowDate.setDate(now.getDate() + 1);
      const tomorrowDateString = formatDateYYYYMMDD(tomorrowDate);

      results.sort((a, b) => new Date(a.valid_from) - new Date(b.valid_from));
      results.forEach(item => {
        const itemDate = new Date(item.valid_from);
        const itemDateStr = formatDateYYYYMMDD(itemDate);
        if (itemDateStr === todayDateString) {
          todayData.push(item);
        } else if (itemDateStr === tomorrowDateString) {
          tomorrowData.push(item);
        }
      });
    }

    function formatDateYYYYMMDD(d) {
      const year  = d.getFullYear();
      const month = String(d.getMonth() + 1).padStart(2, '0');
      const day   = String(d.getDate()).padStart(2, '0');
      return `${year}-${month}-${day}`;
    }

    /************************************************************************************************
     *                                    FIND CURRENT PERIOD                                       *
     ************************************************************************************************/
    function findCurrentPeriod(dataArray) {
      const now = new Date();
      return dataArray.find(period => {
        const start = new Date(period.valid_from);
        const end   = new Date(period.valid_to);
        return start <= now && end > now;
      }) || null;
    }

    /************************************************************************************************
     *                            CALCULATE DAILY METRICS (MIN, MAX, AVG)                           *
     ************************************************************************************************/
    function calculateDailyMetrics(dataArray) {
      if (!dataArray || dataArray.length === 0) {
        return { min: null, max: null, avg: null };
      }
      let minPrice = Infinity;
      let maxPrice = -Infinity;
      let sum = 0;
      dataArray.forEach(interval => {
        const price = interval.value_inc_vat;
        if (price < minPrice) minPrice = price;
        if (price > maxPrice) maxPrice = price;
        sum += price;
      });
      const avg = sum / dataArray.length;
      return { min: minPrice, max: maxPrice, avg };
    }

    /************************************************************************************************
     *                                    RENDER CURRENT PRICE                                      *
     ************************************************************************************************/
    function renderCurrentPrice() {
      const currentPeriod = findCurrentPeriod(todayData);
      if (currentPeriod) {
        const priceStr = currentPeriod.value_inc_vat.toFixed(2);
        priceEl.innerText = `Current Price: ${priceStr} p/kWh`;
        const fromTime = new Date(currentPeriod.valid_from)
          .toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        const toTime   = new Date(currentPeriod.valid_to)
          .toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        timestampEl.innerText = `Valid from: ${fromTime} to ${toTime}`;
      } else {
        priceEl.innerText = 'No current price data available.';
        timestampEl.innerText = '';
      }
    }

    /************************************************************************************************
     *                                    RENDER DAILY METRICS                                      *
     ************************************************************************************************/
    function renderMetrics() {
      const { min, max, avg } = calculateDailyMetrics(todayData);
      if (min === null) {
        minPriceValueEl.innerText = '—';
        maxPriceValueEl.innerText = '—';
        avgPriceValueEl.innerText = '—';
        return;
      }
      minPriceValueEl.innerText = `${min.toFixed(2)} p/kWh`;
      maxPriceValueEl.innerText = `${max.toFixed(2)} p/kWh`;
      avgPriceValueEl.innerText = `${avg.toFixed(2)} p/kWh`;
    }

    /************************************************************************************************
     *                                   RENDER PRICE TABLE                                         *
     *   Color rows by thresholds: <15 = green, <25 = orange, >=25 = red.                           *
     ************************************************************************************************/
    function renderPriceTable() {
      priceTableBodyEl.innerHTML = '';
      const now = new Date();
      const futureIntervals = todayData.filter(interval => {
        const end = new Date(interval.valid_to);
        return end > now;
      });
      if (futureIntervals.length === 0) {
        const noDataRow = document.createElement('tr');
        const noDataCell= document.createElement('td');
        noDataCell.colSpan = 3;
        noDataCell.innerText = 'No more intervals for the rest of today.';
        noDataRow.appendChild(noDataCell);
        priceTableBodyEl.appendChild(noDataRow);
        return;
      }

      futureIntervals.forEach(interval => {
        const row = document.createElement('tr');

        const fromCell  = document.createElement('td');
        const toCell    = document.createElement('td');
        const priceCell = document.createElement('td');

        const fromTime  = new Date(interval.valid_from)
          .toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        fromCell.innerText = fromTime;

        const toTime    = new Date(interval.valid_to)
          .toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        toCell.innerText = toTime;

        const p = interval.value_inc_vat;
        priceCell.innerText = p.toFixed(2);

        // Color code row based on thresholds
        if (p < 15) {
          row.classList.add('price-good');
        } else if (p < 25) {
          row.classList.add('price-ok');
        } else {
          row.classList.add('price-bad');
        }

        row.appendChild(fromCell);
        row.appendChild(toCell);
        row.appendChild(priceCell);
        priceTableBodyEl.appendChild(row);
      });
    }

    /************************************************************************************************
     *                                   RENDER CHART (RESPONSIVE)                                  *
     *   We'll store the data points in a global array (chartPoints) for hover interactivity.        *
     ************************************************************************************************/
    function renderChart() {
      const canvasWidth  = priceChartCanvas.clientWidth;
      const canvasHeight = priceChartCanvas.clientHeight;

      // Adjust canvas resolution for device pixel ratio
      priceChartCanvas.width  = canvasWidth  * window.devicePixelRatio;
      priceChartCanvas.height = canvasHeight * window.devicePixelRatio;
      priceChartCtx.scale(window.devicePixelRatio, window.devicePixelRatio);

      // Clear the stored points
      chartPoints = [];

      // If no data, draw text
      if (!todayData || todayData.length === 0) {
        priceChartCtx.clearRect(0, 0, canvasWidth, canvasHeight);
        priceChartCtx.fillStyle = '#FFFFFF';
        priceChartCtx.fillText('No data for chart', 10, 50);
        return;
      }

      // Sort and compute min/max
      todayData.sort((a, b) => new Date(a.valid_from) - new Date(b.valid_from));
      const minTime = new Date(todayData[0].valid_from).getTime();
      const maxTime = new Date(todayData[todayData.length - 1].valid_to).getTime();

      let minPrice = Infinity;
      let maxPrice = -Infinity;
      todayData.forEach(d => {
        if (d.value_inc_vat < minPrice) minPrice = d.value_inc_vat;
        if (d.value_inc_vat > maxPrice) maxPrice = d.value_inc_vat;
      });
      const priceRange = maxPrice - minPrice || 1;

      // 1) Clear canvas
      priceChartCtx.clearRect(0, 0, canvasWidth, canvasHeight);

      // 2) We'll create chartPoints that store the scaled x,y plus the actual data
      chartPoints = todayData.map(d => {
        const t = new Date(d.valid_from).getTime();
        const xNorm = (t - minTime) / (maxTime - minTime || 1); // 0..1
        const x = xNorm * canvasWidth;
        const yNorm = (d.value_inc_vat - minPrice) / priceRange; // 0..1
        // Flip Y
        const y = canvasHeight - (yNorm * canvasHeight);
        return {
          x, y,
          price: d.value_inc_vat,
          timeFrom: d.valid_from
        };
      });

      // 3) Draw baseline
      priceChartCtx.strokeStyle = '#CCCCCC';
      priceChartCtx.lineWidth   = 1;
      priceChartCtx.beginPath();
      priceChartCtx.moveTo(0, canvasHeight - 1);
      priceChartCtx.lineTo(canvasWidth, canvasHeight - 1);
      priceChartCtx.stroke();

      // 4) Draw the line
      priceChartCtx.strokeStyle = '#FF00E5';
      priceChartCtx.lineWidth   = 2;
      priceChartCtx.beginPath();
      chartPoints.forEach((pt, index) => {
        if (index === 0) {
          priceChartCtx.moveTo(pt.x, pt.y);
        } else {
          priceChartCtx.lineTo(pt.x, pt.y);
        }
      });
      priceChartCtx.stroke();

      // 5) Circle markers
      priceChartCtx.fillStyle = '#FF00E5';
      chartPoints.forEach(pt => {
        priceChartCtx.beginPath();
        priceChartCtx.arc(pt.x, pt.y, 3, 0, 2*Math.PI);
        priceChartCtx.fill();
      });

      // 6) Show min & max on the side
      priceChartCtx.fillStyle = '#FFFFFF';
      priceChartCtx.fillText(`${minPrice.toFixed(2)} p`, 10, canvasHeight - 10);
      priceChartCtx.fillText(`${maxPrice.toFixed(2)} p`, 10, 20);
    }

    /************************************************************************************************
     *                                CHART INTERACTIVITY (TOOLTIP)                                 *
     ************************************************************************************************/
    function onCanvasHover(e) {
      // We need to figure out the mouse/touch position relative to the canvas
      const rect = priceChartCanvas.getBoundingClientRect();

      // Support both mouse and touch
      let clientX, clientY;
      if (e.touches && e.touches.length > 0) {
        clientX = e.touches[0].clientX;
        clientY = e.touches[0].clientY;
      } else {
        clientX = e.clientX;
        clientY = e.clientY;
      }

      const x = clientX - rect.left;
      const y = clientY - rect.top;

      // Now find the closest data point
      let closestPt = null;
      let minDist   = 9999999;
      chartPoints.forEach(pt => {
        const dx = pt.x - x;
        const dy = pt.y - y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        if (dist < minDist) {
          minDist = dist;
          closestPt = pt;
        }
      });
      // If it’s within 20px of a data point, show the tooltip
      if (closestPt && minDist < 20) {
        showTooltip(closestPt, x, y, rect);
      } else {
        hideTooltip();
      }
    }

    function showTooltip(pt, mouseX, mouseY, boundingRect) {
      chartTooltipEl.innerText = `${pt.price.toFixed(2)} p/kWh`;
      chartTooltipEl.style.left = (boundingRect.left + mouseX + 10) + 'px';
      chartTooltipEl.style.top  = (boundingRect.top + mouseY - 10) + 'px';
      chartTooltipEl.style.opacity = 1;
    }

    function hideTooltip() {
      chartTooltipEl.style.opacity = 0;
    }

    /************************************************************************************************
     *                                  RENDER TOMORROW PREVIEW                                     *
     ************************************************************************************************/
    function renderTomorrowPreview() {
      if (!tomorrowData || tomorrowData.length === 0) {
        tomorrowContentEl.innerText = 'No data available for tomorrow yet.';
        return;
      }
      const { min, max } = calculateDailyMetrics(tomorrowData);
      if (min === null) {
        tomorrowContentEl.innerText = 'No data available for tomorrow yet.';
        return;
      }
      tomorrowContentEl.innerText =
        `Min: ${min.toFixed(2)} p/kWh, Max: ${max.toFixed(2)} p/kWh (tomorrow)`;
    }

    /************************************************************************************************
     *                                      DEBUG FUNCTIONS                                         *
     ************************************************************************************************/
    function showDebug(msg) {
      debugEl.style.display = 'block';
      if (typeof msg === 'object') {
        debugEl.textContent = `Error: ${msg.message || JSON.stringify(msg)}`;
      } else {
        debugEl.textContent = String(msg);
      }
      console.error(msg);
    }
    function hideDebug() {
      debugEl.style.display = 'none';
      debugEl.textContent = '';
    }

    /************************************************************************************************
     *                                        MAIN FLOW                                             *
     ************************************************************************************************/
    async function main() {
      showDebug(`Fetching data for region: ${currentRegion}...`);
      try {
        const data = await fetchAgileData(currentRegion);
        if (!data || !data.results) {
          throw new Error('No data returned by API.');
        }
        hideDebug();

        separateTodayAndTomorrowData(data.results);
        renderCurrentPrice();
        renderMetrics();
        renderPriceTable();
        renderChart();
        renderTomorrowPreview();

        hideDebug();
      } catch (error) {
        showDebug(error);
        priceEl.innerText = 'Error fetching price data.';
        timestampEl.innerText = '';
      }
    }

    main();
    setInterval(main, 30 * 60 * 1000);
  </script>
</body>
</html>
